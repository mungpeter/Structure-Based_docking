#!/usr/bin/env python3

#######################################################################
##
##	Peter M.U. Ung @ MSSM
##	
##  v1.0  - 13.11.13
##  v2.0  - 13.11.20 - add FRED tag to filename for future process
##	               FRED score is 1 decimal place
##  v3.0  - 13.11.25 - change to output number based on SDF, not score
##  v4.0  - 13.12.25 - change the read-write organization to use less 
##	               memory
##  v4.5  - 13.12.27 - fixed bug in sdf file reading added functions,
##	               read GZip and BZip2 files
##  v5.0  - 14.05.27 - change Histogram range, allow optional input
##  v6.0  - 16.12.21 - read sdf if name has "::"
##  v6.1  - 17.11.13 - chomp on SDF molname to avoid backspaces
##  v6.2  - 18.02.28 - set default upper/lower for FRED and Glide
##  v7.0  - 18.08.28 - enable SMARTS match to filter out substructures
##  v8.0  - 18.08.29 - rewrite
##  v8.1  - 18.10.30 - bugfix, SMARTS filters for selection and exclusion
##  v9.0  - 19.05.08 - use Seaborn to improve visual of histogram and add
##                     mpi to reading process, but need to watch out mem
##  v10.  - 19.10.15 - fixed a bug with int(args.all_top)*coll > len(d_df)
##  v11   - 20.09.11   use PandasTools, optional histogram generation
##  v12   - 20.12.20   remove sklearn processes, bugfix
##  v13   - 21.11.29   add xz compression capability
##  v14   - 21.12.24   add Murcko scaffolds to molecules
##  v15   - 22.08.23   bugfix for numeric mol ID, update pandas read_csv behavior
##  v16   - 23.05.11   rewire the exlusion function
##  v17   - 23.10.30   control if remove duplicate molid (stereoisomers)
##  v18   - 23.11.30   read and sort score by sdf tag, make -score optional

##	Take *_score.txt generated by OpenEye FRED docking to rank molecules.
##	Then read in corresponding SDFs to select ranked molecules for output.
##	Print out the top-ranking sdf molecules and generate a histogram.	
##    -select|-exclude option enables filtering of molecules with matching
##    substructure
##
##	Required:	fred_screen_preprocess.py
##			*.fred_docked.sdf(.bz2|.gz|.xz)
##
#######################################################################

import sys
MSG = """\n  ## Usage: x.py 
      -sdf     <+>  [ sdf files: sdf ]      # gzip/xz/bzip2 okay
      -top     < >  [ Number of Top MOL in output: int ]
      -dock    < >  [ docking software: fred | sch | etc ]
      -outpref < >  [ Prefix of Output sdf, png, and txt files ]\n
  Optional:
      -score   <+>  [ score files: txt ]    # gzip/xz/bzip2 okay
                text format: '<molID>\s<Score>'
      -id_col  < >  [ SDF tag to match mol Name  to score file (def: original title) ]
      -score_col < >[ SDF tag to match mol Score to score file (def: original title) ]
      -keepdup      [ Keep duplicate molID (enumeration of undefined chiral atoms) ]
      -murcko       [ Add Murcko structure (def: False) ]
      -init    < >  [ Number of mol stored internally from each SDF file (def: = -top) ] 
      -exclude < >  [ <SMILES filter> (smt-clean) ]   removal filter
      -select  < >  [ <SMILES filter> (smt-selec) ]   selection filter
                    [ use when SMARTS filtering is enabled ]\n
    FRED/HYBRID score tag: Chemgauss4
    GlideSP score tag:     r_i_glide_gscore\n
  e.g.:  x.py -score "*_score.txt" -sdf "*.sdf" 
              -top 1000 -dock sch -outpref ksr-allost 
              -exclude 'C(=O)[O-]|S(=O)(=O)[O-]|P(=O)(O)[O-]'  # acidic moieties\n"""
if len(sys.argv) == 1: sys.exit(MSG)

import glob,re,gc
import gzip,bz2,lzma
import pandas as pd
import multiprocessing

#from tqdm import tqdm
from rdkit import Chem
from rdkit.Chem import PandasTools as rdpd

from argparse import ArgumentParser

############################################################################
def doit( ):

  args = UserInput()
  if not args.init:
    args.init = args.all_top

  if args.arg_exc and args.arg_sel:
    sys.exit('  ERROR: Can only take either Exlcude or Selection, not both\n')
  elif args.arg_exc and not args.arg_sel:
    switch = 'exclude'
    smiles = args.arg_exc
  elif not args.arg_exc and args.arg_sel:
    switch = 'include'
    smiles = args.arg_sel
  else:
    switch = False
    smiles = False

######################
  ## format the output name based on number of top output
  if int(args.all_top) >= 1000:
    top_name = '{0}.{1}_top{2}k'.format( args.prefix, args.dock, int(int(args.all_top)/1000) )
  else:
    top_name = '{0}.{1}_top{2}'.format( args.prefix, args.dock, int(args.all_top) )

######################

  ## Read in the score files
  if args.all_txt is None:
    print('\033[31mUse SDF Score Tag [\033[32m{0}\033[31m] for Score Ranking\033[0m'.format(args.score_col))
    score_df = False
  else:
    File_Names = list(glob.glob(args.all_txt))
    print("\033[31mScore Files:\033[0m")
    print(File_Names)

    mpi  = multiprocessing.Pool()
    Data = [x for x in mpi.imap(ExtractScore,File_Names)]
#    Data = [ExtractScore(fn) for fn in tqdm(File_Names,total=len(File_Names))]
    mpi.close()
    mpi.join()

    ## Extract molID and score, specifically the first 2 columns in the texts
    ## if other columns are used for molID/score, specify both
    df = pd.concat(Data)
    print('## Original data head:')
    print(df[:3])
    if not args.id_col and not args.score_col:
      c_df = df[df.columns[0:2]]
    else:
      c_df = df[[args.id_col, args.score_col]]
    print('## Extracted data head:')
    print(c_df[:3])

    ## ZINC library molname can be numeric, create issue with pandas/numpy handling
    ## convert any numeric molname into string
    ## in case score is read as string, convert to float
    c_df.columns = [args.id_col, args.score_col]	# rename the columns
    c_df[args.id_col] = c_df[args.id_col].astype(str)
    c_df[args.score_col] = c_df[args.score_col].apply(float)

    d_df = c_df.sort_values(by=[args.score_col]).reset_index(drop=True)
    print('\033[31m## Entries read:\033[0m {0}\n'.format(len(df)))
    print('## Processed data head:')
    print(d_df[:3])

    score_df = d_df[:int(args.all_top)]


##################

  # Read in SDF file name
  SDF_Names = glob.glob(args.all_sdf)

  ## Read in top SDF files and build ranked SDF file
  mpi = multiprocessing.Pool( processes=int(multiprocessing.cpu_count()/2) )
  sdfdata = CollectSDFData( score_df=score_df, init=int(args.init), smiles=smiles,
                            score_col=args.score_col, id_col=args.id_col )
#  Temp = [x for x in tqdm(mpi.imap(sdfdata, SDF_Names), total=len(SDF_Names))]
  Temp = [sdfdata(sdf) for sdf in SDF_Names]
  mpi.close()
  mpi.join()
  raw_sdf = pd.concat(Temp).sort_values(by=args.score_col)

  ## Duplicated mol_id due to enumeration of undefined chiral centers
  if args.keepdup:
    top_sdf = raw_sdf.reset_index(drop=True).reset_index()
    print('\033[33m## Duplicated mol_id (enumerated undefined chiral center) are kept ##\033[0m')
  else:
    top_sdf = raw_sdf.drop_duplicates(subset=args.id_col,keep='first').reset_index(drop=True).reset_index()
    print('\033[31m## Duplicated mol_id are removed ##\033[0m')
  print(top_sdf[args.score_col])

  ## Rename molid to include score and rank order
  top_sdf['NewID'] = ['{0}::{1}::{2:.2f}::{3}'.format(row[args.id_col],i+1,row[args.score_col],args.dock) for i,row in top_sdf.iterrows() ]
#  top_sdf['Ranking'] = top_sdf.index.apply(lambda x: int(x)+1)  # pandas update broken it
  top_sdf['Ranking'] = [ x+1 for x in top_sdf.index.to_list() ]
  print('Total taken: {0}\n'.format(len(top_sdf)))

########################

  WriteSDFDataSelect( top_sdf, args.all_top, top_name, args.id_col, args.score_col, switch, args.murcko )



##########################################################################
##########################################################################
def ExtractScore( fname ):
  print('file_name: '+str(fname))
  df = pd.read_csv(fname, sep='\t', comment='#', index_col=False)
  print('# Ligand Collected: {0}'.format(len(df)))
  return df


##########################################################################
## Build a database of molecules from SDF files
class CollectSDFData(object):
  def __init__( self, score_df=False, init=0, id_col='ID', smiles=False, score_col='' ):
    self.score_df = score_df
    self.id_col = id_col
    self.init   = init	# initial saved enry from each sdf file
    self.smiles = smiles
    self.score_col  = score_col

  def __call__( self, sdf_file ):
    return self._read_sdf(sdf_file)

  def _read_sdf( self, sdf_file ):

    ## Build a library of molecules found in the Top-Selction List
    df = rdpd.LoadSDF(file_handle(sdf_file), molColName='ROMol', idName='ID', removeHs=False)
    df[self.id_col]    = df[self.id_col].astype(str)		# deal with numeric molid
    df[self.score_col] = df[self.score_col].apply(float)	# deal with string numbers

########################
    ## Ensure there is a sdf Tag 'Score' for later use
    if self.score_col != 'Score':
      df['Score'] = df[self.score_col]

    ## Tag entry if it matches the smiles
    if self.smiles:
      match = []
      for smiles in [ smiles for smiles in self.smiles.split('|') ]:
        print(smiles)
        match.append( df['ROMol'].apply(lambda x: x.HasSubstructMatch(Chem.MolFromSmiles(smiles))) )

      Select = []
      for mol in list(zip(*match)):
        if True in set(mol):
          Select.append(True)
        else:
          Select.append(False)
      df['match'] = Select
      print('# No. of entries matched the selection smiles: {0}'.format(len(df[df.match == True])))

########################

    ## Slice the full SDF and collect only SDF with the specific ID/Name in self.name
    if self.score_df == False:
      top_df = df       # no slicing of MOL
    else:
      sel_df = df[ df[self.id_col].isin(self.score_df[self.id_col]) ]
      top_df = pd.merge(sel_df, self.score_df, on=self.id_col)

########################
    print('  # SDF input > {0} : {1}, take {2}'.format(sdf_file, len(df), len(top_df)))

    del df
    gc.collect()    # active collection of memory to avoid crash
    return top_df


#######################################################################
def WriteSDFDataSelect( top_sdf, all_top, top_name, id_col, score_col, switch, murcko ):

  ## 'switch' between to use smarts 'include/exclude' in sdf writeout
  if switch == False:
    outpref = top_name
    sel_sdf = top_sdf
  else:
    outpref = top_name+'.'+switch
    if switch == 'include':
      sel_sdf = top_sdf[top_sdf['match'] == True ].reset_index(drop=True)
    elif switch == 'exclude':
      sel_sdf = top_sdf[top_sdf['match'] == False].reset_index(drop=True)
    print('# No. of entries after "{0}": {1}'.format(switch, len(sel_sdf)))

  ## Select top ranking entries for export
  if len(top_sdf) > int(all_top):
    final_sdf = sel_sdf[:int(all_top)]
  else:
    final_sdf = sel_sdf
  print(final_sdf[score_col])

  ## Option to include Murcko structures
  if murcko:
    rdpd.AddMurckoToFrame(final_sdf, molCol='ROMol', MurckoCol='HeteroMurcko_SMILES', Generic=False)
    rdpd.AddMurckoToFrame(final_sdf, molCol='ROMol', MurckoCol='Murcko_SMILES', Generic=True)

  rdpd.WriteSDF(final_sdf, '{0}.sdf.gz'.format(outpref), idName='NewID', properties=list(final_sdf.columns))
  sel_sdf.to_csv('{0}.txt.gz'.format(outpref), columns=[id_col,'Ranking',score_col], sep='\t', index=False)


#######################################################################
## to handle the raw SDF format, python3's rdkit has a documented bug and
## hasn't been fixed since 2016. https://github.com/rdkit/rdkit/issues/1065
## To avoid it, the input file cannot be an object handle of a regular file,
## i.e. handle = open('xxx.sdf','r') will fail but handle = 'xxx.sdf' is fine.
## It only happens to regular file but not to gzip.open() or bz2.BZ2File() in
## python3 rdkit but not in python2 rdkit...
## Fix it by replace handle = open('xxx.sdf','r') with handle = 'xxx.sdf'

## Handle gzip and bzip2 file if the extension is right. otherwise, just open
## outuput: file handle
def file_handle(file_name):
  if re.search(r'.gz$', file_name):
    handle = gzip.open(file_name, 'rb')
  elif re.search(r'.xz$', file_name):
    handle = lzma.open(file_name, 'rb')
  elif re.search(r'.bz2$', file_name):
    handle = bz2.BZ2File(file_name, 'rb')
  else:
    handle = open(file_name, 'rb')
  return handle

###########################################################################
#### Default boundary constant for Histogram and changes ####
grid= False

def UserInput():
  p = ArgumentParser(description='Command Line Arguments')

  p.add_argument('-score', dest='all_txt', required=False, default=None,
                  help='Score Files: txt')
  p.add_argument('-sdf', dest='all_sdf', required=True,
                  help='sdf files: sdf')
  p.add_argument('-top', dest='all_top', required=True,
                  help='Numner of Top mol in output: int')
  p.add_argument('-dock', dest='dock', required=True,
                  help='docking software: fred | sch | etc')
  p.add_argument('-outpref', dest='prefix', required=True,
                  help='Prefix of Output sdf, png, and txt files')

  p.add_argument('-init', dest='init', required=False, default=False,
                  help='Optional: Initial number of entry in each SDF file to be kept (def: same as -top)')
  p.add_argument('-murcko', dest='murcko', required=False, action='store_true',
                  help='Optional: Add Murcko structure (def: False)')
  p.add_argument('-id_col', dest='id_col', required=False, default='ID',
                  help='Optional: SDF Tag to match Mol_id to score file (def: original title)')
  p.add_argument('-score_col', dest='score_col', required=False, default='Score',
                  help='Optional: SDF Tag to match Score_Col to score file (def: original title)')
  p.add_argument('-keepdup', dest='keepdup', required=False, action='store_true',
                  help='Optional: Keep duplicate mol_id (enumeration of undefined chiral centers)')

  p.add_argument('-exclude', dest='arg_exc', required=False, default=None,
                  help='[Optional: -exclude=<SMARTS filter> (smt-clean)] removal filter')
  p.add_argument('-select', dest='arg_sel', required=False, default=None,
                  help='[optional: -select=<SMARTS filter>  (smt-selec)] selection filter\n[             use when SMARTS filtering is enabled ]')

  args = p.parse_args()
  return args

############################################################################
if __name__ == '__main__':
  doit(  )
